//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedList.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using Unity.Collections.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using UnityEngine.Internal;
using System.Collections;

namespace Unity.Collections
{
    struct FixedList
    {             
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckElementAccess(int index, int Length)
        {
            if (index < 0 || index >= Length)
                throw new IndexOutOfRangeException($"Index {index} is out of range of '{Length}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        public static void CheckResize(int newLength, int Capacity)
        {
            if (newLength < 0 || newLength > Capacity)
                throw new IndexOutOfRangeException($"NewLength {newLength} is out of range of '{Capacity}' Capacity.");
        }
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory. 
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListByte32DebugView))]
    public struct FixedListByte32 
    : IEnumerable<byte>
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes30 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(byte);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes30>() / sizeof(byte);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<byte>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<byte>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte32.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(byte item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListByte32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte32.</param>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte32 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte32.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32.</param>
        public int IndexOf(byte item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListByte32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(byte);
                    byte *src = b + begin * sizeof(byte);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListByte32 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte32.</param>
        public void RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListByte32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(byte);
                    byte *src = b + end * sizeof(byte);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, byte item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte32 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte32</param> 
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte32.
        /// </summary>
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                fixed(byte* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte32.
        /// </summary>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.Invalid);        
                    return new NativeArray<byte>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListByte32.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((byte*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param> 
        /// <param name="b">The FixedListByte32 to compare for equality</param> 
        public static bool operator ==(in FixedListByte32 a, in FixedListByte32 b)
        {
            unsafe
            {
                fixed(FixedListByte32* aa = &a)
                fixed(FixedListByte32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param> 
        /// <param name="b">The FixedListByte32 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte32 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        public int CompareTo(FixedListByte32 other)       
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        public bool Equals(FixedListByte32 other)
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param> 
        /// <param name="b">The FixedListByte64 to compare for equality</param> 
        public static bool operator ==(in FixedListByte32 a, in FixedListByte64 b)
        {
            unsafe
            {
                fixed(FixedListByte32* aa = &a)
                fixed(FixedListByte64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param> 
        /// <param name="b">The FixedListByte64 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte32 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        public int CompareTo(FixedListByte64 other)       
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        public bool Equals(FixedListByte64 other)
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte32(in FixedListByte64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte64* o = &other)
                    this = *(FixedListByte32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public static implicit operator FixedListByte32(in FixedListByte64 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for equality</param> 
        /// <param name="b">The FixedListByte128 to compare for equality</param> 
        public static bool operator ==(in FixedListByte32 a, in FixedListByte128 b)
        {
            unsafe
            {
                fixed(FixedListByte32* aa = &a)
                fixed(FixedListByte128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte32 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte32 to compare for inequality</param> 
        /// <param name="b">The FixedListByte128 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte32 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        public int CompareTo(FixedListByte128 other)       
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        public bool Equals(FixedListByte128 other)
        {
            unsafe
            {
                fixed(FixedListByte32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte32 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte32(in FixedListByte128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte128* o = &other)
                    this = *(FixedListByte32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public static implicit operator FixedListByte32(in FixedListByte128 other)
        {
            return new FixedListByte32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte32 m_List;
            int m_Index;

            public Enumerator(ref FixedListByte32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListByte32 indexer check for out of range.
            public byte Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListByte32DebugView
    {
        FixedListByte32 m_List;
        public FixedListByte32DebugView(FixedListByte32 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory. 
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListByte64DebugView))]
    public struct FixedListByte64 
    : IEnumerable<byte>
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes62 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(byte);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes62>() / sizeof(byte);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<byte>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<byte>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte64.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(byte item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListByte64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte64.</param>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte64 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte64.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64.</param>
        public int IndexOf(byte item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListByte64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(byte);
                    byte *src = b + begin * sizeof(byte);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListByte64 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte64.</param>
        public void RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListByte64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(byte);
                    byte *src = b + end * sizeof(byte);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, byte item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte64 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte64</param> 
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte64.
        /// </summary>
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                fixed(byte* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte64.
        /// </summary>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.Invalid);        
                    return new NativeArray<byte>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListByte64.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((byte*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param> 
        /// <param name="b">The FixedListByte32 to compare for equality</param> 
        public static bool operator ==(in FixedListByte64 a, in FixedListByte32 b)
        {
            unsafe
            {
                fixed(FixedListByte64* aa = &a)
                fixed(FixedListByte32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param> 
        /// <param name="b">The FixedListByte32 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte64 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        public int CompareTo(FixedListByte32 other)       
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        public bool Equals(FixedListByte32 other)
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte64(in FixedListByte32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte32* o = &other)
                    this = *(FixedListByte64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public static implicit operator FixedListByte64(in FixedListByte32 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param> 
        /// <param name="b">The FixedListByte64 to compare for equality</param> 
        public static bool operator ==(in FixedListByte64 a, in FixedListByte64 b)
        {
            unsafe
            {
                fixed(FixedListByte64* aa = &a)
                fixed(FixedListByte64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param> 
        /// <param name="b">The FixedListByte64 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte64 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        public int CompareTo(FixedListByte64 other)       
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        public bool Equals(FixedListByte64 other)
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for equality</param> 
        /// <param name="b">The FixedListByte128 to compare for equality</param> 
        public static bool operator ==(in FixedListByte64 a, in FixedListByte128 b)
        {
            unsafe
            {
                fixed(FixedListByte64* aa = &a)
                fixed(FixedListByte128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte64 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte64 to compare for inequality</param> 
        /// <param name="b">The FixedListByte128 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte64 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        public int CompareTo(FixedListByte128 other)       
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        public bool Equals(FixedListByte128 other)
        {
            unsafe
            {
                fixed(FixedListByte64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte64 that is a copy of a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public FixedListByte64(in FixedListByte128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte128* o = &other)
                    this = *(FixedListByte64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte128 to a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte128 to copy</param>
        public static implicit operator FixedListByte64(in FixedListByte128 other)
        {
            return new FixedListByte64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte64 m_List;
            int m_Index;

            public Enumerator(ref FixedListByte64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListByte64 indexer check for out of range.
            public byte Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListByte64DebugView
    {
        FixedListByte64 m_List;
        public FixedListByte64DebugView(FixedListByte64 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of byte that does not allocate memory. 
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListByte128DebugView))]
    public struct FixedListByte128 
    : IEnumerable<byte>
    , IEquatable<FixedListByte32>
    , IComparable<FixedListByte32>
    , IEquatable<FixedListByte64>
    , IComparable<FixedListByte64>
    , IEquatable<FixedListByte128>
    , IComparable<FixedListByte128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes126 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(byte);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes126>() / sizeof(byte);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public byte this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<byte>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<byte>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListByte128.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(byte item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The byte to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(byte item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListByte128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListByte128.</param>
        public bool Contains(byte item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte128 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(byte item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListByte128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(byte item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified byte and returns the zero-based index of the first occurrence within the entire FixedListByte128.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128.</param>
        public int IndexOf(byte item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListByte128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(byte);
                    byte *src = b + begin * sizeof(byte);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListByte128 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListByte128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListByte128.</param>
        public void RemoveSwapBack(byte item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListByte128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(byte);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(byte);
                    byte *src = b + end * sizeof(byte);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListByte128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, byte item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified byte from the begining of the FixedListByte128 forward, removes it if possible,
        /// and returns true if the byte was successfully removed.
        /// </summary>
        /// <param name="item">The byte to locate in the FixedListByte128</param> 
        public bool Remove(byte item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the byte at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the byte</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of byte that is a copy of this FixedListByte128.
        /// </summary>
        public byte[] ToArray()
        {
            var result = new byte[Length];
            unsafe
            {
                fixed(byte* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArraybyte that is a copy of this FixedListByte128.
        /// </summary>
        public NativeArray<byte> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<byte>(s, Length, Allocator.Invalid);        
                    return new NativeArray<byte>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListByte128.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((byte*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param> 
        /// <param name="b">The FixedListByte32 to compare for equality</param> 
        public static bool operator ==(in FixedListByte128 a, in FixedListByte32 b)
        {
            unsafe
            {
                fixed(FixedListByte128* aa = &a)
                fixed(FixedListByte32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte32 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param> 
        /// <param name="b">The FixedListByte32 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte128 a, in FixedListByte32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with</param>
        public int CompareTo(FixedListByte32 other)       
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte32 and indicates whether this instance 
        /// is equal to the specified FixedListByte32.
        /// </summary>
        /// <param name="other">The specified FixedListByte32 to compare with for equality</param>
        public bool Equals(FixedListByte32 other)
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte32.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public FixedListByte128(in FixedListByte32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte32* o = &other)
                    this = *(FixedListByte128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte32 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte32 to copy</param>
        public static implicit operator FixedListByte128(in FixedListByte32 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param> 
        /// <param name="b">The FixedListByte64 to compare for equality</param> 
        public static bool operator ==(in FixedListByte128 a, in FixedListByte64 b)
        {
            unsafe
            {
                fixed(FixedListByte128* aa = &a)
                fixed(FixedListByte64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte64 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param> 
        /// <param name="b">The FixedListByte64 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte128 a, in FixedListByte64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with</param>
        public int CompareTo(FixedListByte64 other)       
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte64 and indicates whether this instance 
        /// is equal to the specified FixedListByte64.
        /// </summary>
        /// <param name="other">The specified FixedListByte64 to compare with for equality</param>
        public bool Equals(FixedListByte64 other)
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListByte128 that is a copy of a FixedListByte64.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public FixedListByte128(in FixedListByte64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(byte));
            unsafe 
            {
                fixed(FixedListByte64* o = &other)
                    this = *(FixedListByte128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListByte64 to a FixedListByte128.
        /// </summary>
        /// <param name="other">The FixedListByte64 to copy</param>
        public static implicit operator FixedListByte128(in FixedListByte64 other)
        {
            return new FixedListByte128(other);
        }

        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for equality</param> 
        /// <param name="b">The FixedListByte128 to compare for equality</param> 
        public static bool operator ==(in FixedListByte128 a, in FixedListByte128 b)
        {
            unsafe
            {
                fixed(FixedListByte128* aa = &a)
                fixed(FixedListByte128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListByte128 and FixedListByte128 have different values.
        /// </summary>
        /// <param name="a">The FixedListByte128 to compare for inequality</param> 
        /// <param name="b">The FixedListByte128 to compare for inequality</param> 
        public static bool operator !=(in FixedListByte128 a, in FixedListByte128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with</param>
        public int CompareTo(FixedListByte128 other)       
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListByte128 and indicates whether this instance 
        /// is equal to the specified FixedListByte128.
        /// </summary>
        /// <param name="other">The specified FixedListByte128 to compare with for equality</param>
        public bool Equals(FixedListByte128 other)
        {
            unsafe
            {
                fixed(FixedListByte128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListByte32 aFixedListByte32) return Equals(aFixedListByte32);
            if(obj is FixedListByte64 aFixedListByte64) return Equals(aFixedListByte64);
            if(obj is FixedListByte128 aFixedListByte128) return Equals(aFixedListByte128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<byte>
        {
            FixedListByte128 m_List;
            int m_Index;

            public Enumerator(ref FixedListByte128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListByte128 indexer check for out of range.
            public byte Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<byte> IEnumerable<byte>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListByte128DebugView
    {
        FixedListByte128 m_List;
        public FixedListByte128DebugView(FixedListByte128 list)
        {
            m_List = list;
        }
        public byte[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory. 
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListInt32DebugView))]
    public struct FixedListInt32 
    : IEnumerable<int>
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes30 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(int);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes30>() / sizeof(int);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<int>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<int>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt32.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(int item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListInt32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt32.</param>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt32 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt32.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32.</param>
        public int IndexOf(int item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListInt32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(int);
                    byte *src = b + begin * sizeof(int);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListInt32 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt32.</param>
        public void RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListInt32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(int);
                    byte *src = b + end * sizeof(int);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, int item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt32 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt32</param> 
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt32.
        /// </summary>
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                fixed(int* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt32.
        /// </summary>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.Invalid);        
                    return new NativeArray<int>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListInt32.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((int*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param> 
        /// <param name="b">The FixedListInt32 to compare for equality</param> 
        public static bool operator ==(in FixedListInt32 a, in FixedListInt32 b)
        {
            unsafe
            {
                fixed(FixedListInt32* aa = &a)
                fixed(FixedListInt32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param> 
        /// <param name="b">The FixedListInt32 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt32 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        public int CompareTo(FixedListInt32 other)       
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        public bool Equals(FixedListInt32 other)
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param> 
        /// <param name="b">The FixedListInt64 to compare for equality</param> 
        public static bool operator ==(in FixedListInt32 a, in FixedListInt64 b)
        {
            unsafe
            {
                fixed(FixedListInt32* aa = &a)
                fixed(FixedListInt64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param> 
        /// <param name="b">The FixedListInt64 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt32 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        public int CompareTo(FixedListInt64 other)       
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        public bool Equals(FixedListInt64 other)
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt32(in FixedListInt64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt64* o = &other)
                    this = *(FixedListInt32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public static implicit operator FixedListInt32(in FixedListInt64 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for equality</param> 
        /// <param name="b">The FixedListInt128 to compare for equality</param> 
        public static bool operator ==(in FixedListInt32 a, in FixedListInt128 b)
        {
            unsafe
            {
                fixed(FixedListInt32* aa = &a)
                fixed(FixedListInt128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt32 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt32 to compare for inequality</param> 
        /// <param name="b">The FixedListInt128 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt32 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        public int CompareTo(FixedListInt128 other)       
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        public bool Equals(FixedListInt128 other)
        {
            unsafe
            {
                fixed(FixedListInt32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt32 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt32(in FixedListInt128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt128* o = &other)
                    this = *(FixedListInt32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public static implicit operator FixedListInt32(in FixedListInt128 other)
        {
            return new FixedListInt32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt32 m_List;
            int m_Index;

            public Enumerator(ref FixedListInt32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListInt32 indexer check for out of range.
            public int Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<int> IEnumerable<int>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListInt32DebugView
    {
        FixedListInt32 m_List;
        public FixedListInt32DebugView(FixedListInt32 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory. 
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListInt64DebugView))]
    public struct FixedListInt64 
    : IEnumerable<int>
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes62 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(int);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes62>() / sizeof(int);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<int>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<int>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt64.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(int item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListInt64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt64.</param>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt64 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt64.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64.</param>
        public int IndexOf(int item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListInt64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(int);
                    byte *src = b + begin * sizeof(int);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListInt64 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt64.</param>
        public void RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListInt64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(int);
                    byte *src = b + end * sizeof(int);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, int item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt64 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt64</param> 
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt64.
        /// </summary>
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                fixed(int* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt64.
        /// </summary>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.Invalid);        
                    return new NativeArray<int>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListInt64.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((int*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param> 
        /// <param name="b">The FixedListInt32 to compare for equality</param> 
        public static bool operator ==(in FixedListInt64 a, in FixedListInt32 b)
        {
            unsafe
            {
                fixed(FixedListInt64* aa = &a)
                fixed(FixedListInt32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param> 
        /// <param name="b">The FixedListInt32 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt64 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        public int CompareTo(FixedListInt32 other)       
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        public bool Equals(FixedListInt32 other)
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt64(in FixedListInt32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt32* o = &other)
                    this = *(FixedListInt64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public static implicit operator FixedListInt64(in FixedListInt32 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param> 
        /// <param name="b">The FixedListInt64 to compare for equality</param> 
        public static bool operator ==(in FixedListInt64 a, in FixedListInt64 b)
        {
            unsafe
            {
                fixed(FixedListInt64* aa = &a)
                fixed(FixedListInt64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param> 
        /// <param name="b">The FixedListInt64 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt64 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        public int CompareTo(FixedListInt64 other)       
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        public bool Equals(FixedListInt64 other)
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for equality</param> 
        /// <param name="b">The FixedListInt128 to compare for equality</param> 
        public static bool operator ==(in FixedListInt64 a, in FixedListInt128 b)
        {
            unsafe
            {
                fixed(FixedListInt64* aa = &a)
                fixed(FixedListInt128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt64 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt64 to compare for inequality</param> 
        /// <param name="b">The FixedListInt128 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt64 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        public int CompareTo(FixedListInt128 other)       
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        public bool Equals(FixedListInt128 other)
        {
            unsafe
            {
                fixed(FixedListInt64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt64 that is a copy of a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public FixedListInt64(in FixedListInt128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt128* o = &other)
                    this = *(FixedListInt64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt128 to a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt128 to copy</param>
        public static implicit operator FixedListInt64(in FixedListInt128 other)
        {
            return new FixedListInt64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt64 m_List;
            int m_Index;

            public Enumerator(ref FixedListInt64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListInt64 indexer check for out of range.
            public int Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<int> IEnumerable<int>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListInt64DebugView
    {
        FixedListInt64 m_List;
        public FixedListInt64DebugView(FixedListInt64 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of int that does not allocate memory. 
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListInt128DebugView))]
    public struct FixedListInt128 
    : IEnumerable<int>
    , IEquatable<FixedListInt32>
    , IComparable<FixedListInt32>
    , IEquatable<FixedListInt64>
    , IComparable<FixedListInt64>
    , IEquatable<FixedListInt128>
    , IComparable<FixedListInt128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes126 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(int);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes126>() / sizeof(int);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public int this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<int>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<int>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListInt128.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(int item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The int to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(int item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListInt128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListInt128.</param>
        public bool Contains(int item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt128 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(int item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListInt128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(int item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified int and returns the zero-based index of the first occurrence within the entire FixedListInt128.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128.</param>
        public int IndexOf(int item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListInt128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(int);
                    byte *src = b + begin * sizeof(int);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListInt128 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListInt128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListInt128.</param>
        public void RemoveSwapBack(int item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListInt128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(int);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(int);
                    byte *src = b + end * sizeof(int);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListInt128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, int item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified int from the begining of the FixedListInt128 forward, removes it if possible,
        /// and returns true if the int was successfully removed.
        /// </summary>
        /// <param name="item">The int to locate in the FixedListInt128</param> 
        public bool Remove(int item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the int at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the int</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of int that is a copy of this FixedListInt128.
        /// </summary>
        public int[] ToArray()
        {
            var result = new int[Length];
            unsafe
            {
                fixed(int* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayint that is a copy of this FixedListInt128.
        /// </summary>
        public NativeArray<int> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<int>(s, Length, Allocator.Invalid);        
                    return new NativeArray<int>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListInt128.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((int*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param> 
        /// <param name="b">The FixedListInt32 to compare for equality</param> 
        public static bool operator ==(in FixedListInt128 a, in FixedListInt32 b)
        {
            unsafe
            {
                fixed(FixedListInt128* aa = &a)
                fixed(FixedListInt32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt32 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param> 
        /// <param name="b">The FixedListInt32 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt128 a, in FixedListInt32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with</param>
        public int CompareTo(FixedListInt32 other)       
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt32 and indicates whether this instance 
        /// is equal to the specified FixedListInt32.
        /// </summary>
        /// <param name="other">The specified FixedListInt32 to compare with for equality</param>
        public bool Equals(FixedListInt32 other)
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt32.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public FixedListInt128(in FixedListInt32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt32* o = &other)
                    this = *(FixedListInt128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt32 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt32 to copy</param>
        public static implicit operator FixedListInt128(in FixedListInt32 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param> 
        /// <param name="b">The FixedListInt64 to compare for equality</param> 
        public static bool operator ==(in FixedListInt128 a, in FixedListInt64 b)
        {
            unsafe
            {
                fixed(FixedListInt128* aa = &a)
                fixed(FixedListInt64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt64 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param> 
        /// <param name="b">The FixedListInt64 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt128 a, in FixedListInt64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with</param>
        public int CompareTo(FixedListInt64 other)       
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt64 and indicates whether this instance 
        /// is equal to the specified FixedListInt64.
        /// </summary>
        /// <param name="other">The specified FixedListInt64 to compare with for equality</param>
        public bool Equals(FixedListInt64 other)
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListInt128 that is a copy of a FixedListInt64.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public FixedListInt128(in FixedListInt64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(int));
            unsafe 
            {
                fixed(FixedListInt64* o = &other)
                    this = *(FixedListInt128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListInt64 to a FixedListInt128.
        /// </summary>
        /// <param name="other">The FixedListInt64 to copy</param>
        public static implicit operator FixedListInt128(in FixedListInt64 other)
        {
            return new FixedListInt128(other);
        }

        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for equality</param> 
        /// <param name="b">The FixedListInt128 to compare for equality</param> 
        public static bool operator ==(in FixedListInt128 a, in FixedListInt128 b)
        {
            unsafe
            {
                fixed(FixedListInt128* aa = &a)
                fixed(FixedListInt128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListInt128 and FixedListInt128 have different values.
        /// </summary>
        /// <param name="a">The FixedListInt128 to compare for inequality</param> 
        /// <param name="b">The FixedListInt128 to compare for inequality</param> 
        public static bool operator !=(in FixedListInt128 a, in FixedListInt128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with</param>
        public int CompareTo(FixedListInt128 other)       
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListInt128 and indicates whether this instance 
        /// is equal to the specified FixedListInt128.
        /// </summary>
        /// <param name="other">The specified FixedListInt128 to compare with for equality</param>
        public bool Equals(FixedListInt128 other)
        {
            unsafe
            {
                fixed(FixedListInt128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListInt32 aFixedListInt32) return Equals(aFixedListInt32);
            if(obj is FixedListInt64 aFixedListInt64) return Equals(aFixedListInt64);
            if(obj is FixedListInt128 aFixedListInt128) return Equals(aFixedListInt128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<int>
        {
            FixedListInt128 m_List;
            int m_Index;

            public Enumerator(ref FixedListInt128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListInt128 indexer check for out of range.
            public int Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<int> IEnumerable<int>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListInt128DebugView
    {
        FixedListInt128 m_List;
        public FixedListInt128DebugView(FixedListInt128 list)
        {
            m_List = list;
        }
        public int[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory. 
    /// It is 32 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=32)]
    [DebuggerTypeProxy(typeof(FixedListFloat32DebugView))]
    public struct FixedListFloat32 
    : IEnumerable<float>
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes30 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(float);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes30>() / sizeof(float);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<float>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<float>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat32.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(float item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListFloat32.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat32.</param>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat32 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat32 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat32.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32.</param>
        public int IndexOf(float item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListFloat32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(float);
                    byte *src = b + begin * sizeof(float);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListFloat32 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat32 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat32.</param>
        public void RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListFloat32 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(float);
                    byte *src = b + end * sizeof(float);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat32 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, float item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat32 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat32</param> 
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat32.
        /// </summary>
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                fixed(float* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat32.
        /// </summary>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.Invalid);        
                    return new NativeArray<float>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListFloat32.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((float*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param> 
        /// <param name="b">The FixedListFloat32 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat32 b)
        {
            unsafe
            {
                fixed(FixedListFloat32* aa = &a)
                fixed(FixedListFloat32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat32 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        public int CompareTo(FixedListFloat32 other)       
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        public bool Equals(FixedListFloat32 other)
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param> 
        /// <param name="b">The FixedListFloat64 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat64 b)
        {
            unsafe
            {
                fixed(FixedListFloat32* aa = &a)
                fixed(FixedListFloat64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat64 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        public int CompareTo(FixedListFloat64 other)       
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        public bool Equals(FixedListFloat64 other)
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat32(in FixedListFloat64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat64* o = &other)
                    this = *(FixedListFloat32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public static implicit operator FixedListFloat32(in FixedListFloat64 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for equality</param> 
        /// <param name="b">The FixedListFloat128 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat32 a, in FixedListFloat128 b)
        {
            unsafe
            {
                fixed(FixedListFloat32* aa = &a)
                fixed(FixedListFloat128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat32 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat32 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat128 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat32 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        public int CompareTo(FixedListFloat128 other)       
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        public bool Equals(FixedListFloat128 other)
        {
            unsafe
            {
                fixed(FixedListFloat32* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat32 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat32(in FixedListFloat128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes30>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat128* o = &other)
                    this = *(FixedListFloat32*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public static implicit operator FixedListFloat32(in FixedListFloat128 other)
        {
            return new FixedListFloat32(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat32 m_List;
            int m_Index;

            public Enumerator(ref FixedListFloat32 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListFloat32 indexer check for out of range.
            public float Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<float> IEnumerable<float>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListFloat32DebugView
    {
        FixedListFloat32 m_List;
        public FixedListFloat32DebugView(FixedListFloat32 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory. 
    /// It is 64 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=64)]
    [DebuggerTypeProxy(typeof(FixedListFloat64DebugView))]
    public struct FixedListFloat64 
    : IEnumerable<float>
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes62 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(float);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes62>() / sizeof(float);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<float>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<float>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat64.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(float item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListFloat64.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat64.</param>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat64 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat64 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat64.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64.</param>
        public int IndexOf(float item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListFloat64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(float);
                    byte *src = b + begin * sizeof(float);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListFloat64 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat64 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat64.</param>
        public void RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListFloat64 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(float);
                    byte *src = b + end * sizeof(float);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat64 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, float item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat64 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat64</param> 
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat64.
        /// </summary>
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                fixed(float* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat64.
        /// </summary>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.Invalid);        
                    return new NativeArray<float>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListFloat64.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((float*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param> 
        /// <param name="b">The FixedListFloat32 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat32 b)
        {
            unsafe
            {
                fixed(FixedListFloat64* aa = &a)
                fixed(FixedListFloat32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat32 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        public int CompareTo(FixedListFloat32 other)       
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        public bool Equals(FixedListFloat32 other)
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat64(in FixedListFloat32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat32* o = &other)
                    this = *(FixedListFloat64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public static implicit operator FixedListFloat64(in FixedListFloat32 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param> 
        /// <param name="b">The FixedListFloat64 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat64 b)
        {
            unsafe
            {
                fixed(FixedListFloat64* aa = &a)
                fixed(FixedListFloat64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat64 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        public int CompareTo(FixedListFloat64 other)       
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        public bool Equals(FixedListFloat64 other)
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for equality</param> 
        /// <param name="b">The FixedListFloat128 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat64 a, in FixedListFloat128 b)
        {
            unsafe
            {
                fixed(FixedListFloat64* aa = &a)
                fixed(FixedListFloat128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat64 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat64 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat128 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat64 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        public int CompareTo(FixedListFloat128 other)       
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        public bool Equals(FixedListFloat128 other)
        {
            unsafe
            {
                fixed(FixedListFloat64* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat64 that is a copy of a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public FixedListFloat64(in FixedListFloat128 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes62>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat128* o = &other)
                    this = *(FixedListFloat64*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat128 to a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat128 to copy</param>
        public static implicit operator FixedListFloat64(in FixedListFloat128 other)
        {
            return new FixedListFloat64(other);
        }

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat64 m_List;
            int m_Index;

            public Enumerator(ref FixedListFloat64 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListFloat64 indexer check for out of range.
            public float Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<float> IEnumerable<float>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListFloat64DebugView
    {
        FixedListFloat64 m_List;
        public FixedListFloat64DebugView(FixedListFloat64 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }


    /// <summary>
    /// An unmanaged, resizable list of float that does not allocate memory. 
    /// It is 128 bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=128)]
    [DebuggerTypeProxy(typeof(FixedListFloat128DebugView))]
    public struct FixedListFloat128 
    : IEnumerable<float>
    , IEquatable<FixedListFloat32>
    , IComparable<FixedListFloat32>
    , IEquatable<FixedListFloat64>
    , IComparable<FixedListFloat64>
    , IEquatable<FixedListFloat128>
    , IComparable<FixedListFloat128>
    
    {
        [FieldOffset(0)] internal ushort length;     
        [FieldOffset(2)] internal Bytes126 buffer;   

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize(value, Capacity);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(float);

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity => UnsafeUtility.SizeOf<Bytes126>() / sizeof(float);

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public float this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        return UnsafeUtility.ReadArrayElement<float>(b, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    fixed (void* b = &buffer.byte0000)
                        UnsafeUtility.WriteArrayElement<float>(b, index, value);
                }
            }
        }

        /// <summary>
        /// Computes a hash code summary of the FixedListFloat128.
        /// </summary>
        public override int GetHashCode()
        {
            unsafe 
            {
                fixed (byte* b = &buffer.byte0000)
                    return (int)CollectionHelper.Hash(b, LengthInBytes);
            }
        }
                        
        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void Add(float item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="element">The float to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>        
        public void AddNoResize(float item)
        {
            this[Length++] = item;
        }
                
        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }
    
        /// <summary>
        /// Determines whether an element is in the FixedListFloat128.
        /// </summary>
        /// <param name="item">The object to locate in the FixedListFloat128.</param>
        public bool Contains(float item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat128 that starts at the specified index and contains the specified 
        /// number of elements.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        /// <param name="count">The number of elements in the section to search.</param>
        public int IndexOf(float item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;            
        }

        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the 
        /// range of elements in the FixedListFloat128 that starts at the specified index.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param> 
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param> 
        public int IndexOf(float item, int index)
        {
            return IndexOf(item, index, Length - index);
        }
        
        /// <summary>
        /// Searches for the specified float and returns the zero-based index of the first occurrence within the entire FixedListFloat128.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128.</param>
        public int IndexOf(float item)
        {
            return IndexOf(item, 0, Length);
        }
                                
        /// <summary>
        /// Inserts a number of items into a FixedListFloat128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="items">The number of items to insert</param>                                
        public void InsertRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + end * sizeof(float);
                    byte *src = b + begin * sizeof(float);
                    UnsafeUtility.MemMove(dest, src, bytesToCopy);
                }
            }
        }
                
        /// <summary>
        /// Removes an element from the FixedListFloat128 at the specified index and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="index">The zero-based index of the elements to remove.</param>
        public void RemoveAtSwapBack(int index)
        {
            this[index] = this[Length-1];
            --Length;
        }

        /// <summary>
        /// Removes the first occurrence of an item from the FixedListFloat128 and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the FixedListFloat128.</param>
        public void RemoveSwapBack(float item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }
                
        /// <summary>
        /// Removes a number of elements from a FixedListFloat128 at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the elements should be removed.</param>
        /// <param name="items">The number of elements to remove</param>                                
        public void RemoveRange(int begin, int items)
        {
            if(items < 1)
                return;
            int itemsToCopy = length - (begin + items);
            Length -= items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(float);
            int end = begin + items;
            unsafe
            { 
                fixed(byte *b = &buffer.byte0000)
                { 
                    byte *dest = b + begin * sizeof(float);
                    byte *src = b + end * sizeof(float);
                    UnsafeUtility.MemCpy(dest, src, bytesToCopy);
                }
            }
        }

        /// <summary>
        /// Inserts a single element into a FixedListFloat128 at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>                                
        public void Insert(int index, float item)
        {
            InsertRange(index, index+1);
            this[index] = item;            
        }

        /// <summary>
        /// Searches for the specified float from the begining of the FixedListFloat128 forward, removes it if possible,
        /// and returns true if the float was successfully removed.
        /// </summary>
        /// <param name="item">The float to locate in the FixedListFloat128</param> 
        public bool Remove(float item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }
        
        /// <summary>
        /// Removes the float at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the float</param> 
        public void RemoveAt(int index)
        {
            RemoveRange(index, 1);
        }
        
        /// <summary>
        /// Creates a managed Array of float that is a copy of this FixedListFloat128.
        /// </summary>
        public float[] ToArray()
        {
            var result = new float[Length];
            unsafe
            {
                fixed(float* d = result)
                fixed(byte* s = &buffer.byte0000)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArrayfloat that is a copy of this FixedListFloat128.
        /// </summary>
        public NativeArray<float> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                fixed(byte *s = &buffer.byte0000)
                {
                    var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(s, Length, Allocator.Invalid);        
                    return new NativeArray<float>(copy, allocator);
                }
            }
        }
        
        /// <summary>
        /// Sorts the elements in this FixedListFloat128.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                fixed(byte *b = &buffer.byte0000)
                    NativeSortExtension.Sort((float*)b, length);
            }
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat32 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param> 
        /// <param name="b">The FixedListFloat32 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat32 b)
        {
            unsafe
            {
                fixed(FixedListFloat128* aa = &a)
                fixed(FixedListFloat32* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat32 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat32 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat32 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with</param>
        public int CompareTo(FixedListFloat32 other)       
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat32 and indicates whether this instance 
        /// is equal to the specified FixedListFloat32.
        /// </summary>
        /// <param name="other">The specified FixedListFloat32 to compare with for equality</param>
        public bool Equals(FixedListFloat32 other)
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat32.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public FixedListFloat128(in FixedListFloat32 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat32* o = &other)
                    this = *(FixedListFloat128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat32 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat32 to copy</param>
        public static implicit operator FixedListFloat128(in FixedListFloat32 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat64 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param> 
        /// <param name="b">The FixedListFloat64 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat64 b)
        {
            unsafe
            {
                fixed(FixedListFloat128* aa = &a)
                fixed(FixedListFloat64* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat64 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat64 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat64 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with</param>
        public int CompareTo(FixedListFloat64 other)       
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat64 and indicates whether this instance 
        /// is equal to the specified FixedListFloat64.
        /// </summary>
        /// <param name="other">The specified FixedListFloat64 to compare with for equality</param>
        public bool Equals(FixedListFloat64 other)
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Constructs a new FixedListFloat128 that is a copy of a FixedListFloat64.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public FixedListFloat128(in FixedListFloat64 other)
        {
            FixedList.CheckResize(other.length, UnsafeUtility.SizeOf<Bytes126>() / sizeof(float));
            unsafe 
            {
                fixed(FixedListFloat64* o = &other)
                    this = *(FixedListFloat128*)o;
            }
        }
        
        /// <summary>
        /// Implicitly converts a FixedListFloat64 to a FixedListFloat128.
        /// </summary>
        /// <param name="other">The FixedListFloat64 to copy</param>
        public static implicit operator FixedListFloat128(in FixedListFloat64 other)
        {
            return new FixedListFloat128(other);
        }

        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat128 have the same value.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for equality</param> 
        /// <param name="b">The FixedListFloat128 to compare for equality</param> 
        public static bool operator ==(in FixedListFloat128 a, in FixedListFloat128 b)
        {
            unsafe
            {
                fixed(FixedListFloat128* aa = &a)
                fixed(FixedListFloat128* bb = &b)
                    return UnsafeUtility.MemCmp(aa, bb, sizeof(ushort) + a.LengthInBytes) == 0;
            }
        }
        
        /// <summary>
        /// Determines whether a FixedListFloat128 and FixedListFloat128 have different values.
        /// </summary>
        /// <param name="a">The FixedListFloat128 to compare for inequality</param> 
        /// <param name="b">The FixedListFloat128 to compare for inequality</param> 
        public static bool operator !=(in FixedListFloat128 a, in FixedListFloat128 b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// precedes, follows, or appears in the same position in the sort order as the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with</param>
        public int CompareTo(FixedListFloat128 other)       
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes);
            }
        }
        
        /// <summary>
        /// Compares this instance with a specified FixedListFloat128 and indicates whether this instance 
        /// is equal to the specified FixedListFloat128.
        /// </summary>
        /// <param name="other">The specified FixedListFloat128 to compare with for equality</param>
        public bool Equals(FixedListFloat128 other)
        {
            unsafe
            {
                fixed(FixedListFloat128* t = &this)
                    return UnsafeUtility.MemCmp(t, &other, sizeof(ushort) + LengthInBytes) == 0;
            }
        }
        

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance 
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        public override bool Equals(object obj)
        {
            if(obj is FixedListFloat32 aFixedListFloat32) return Equals(aFixedListFloat32);
            if(obj is FixedListFloat64 aFixedListFloat64) return Equals(aFixedListFloat64);
            if(obj is FixedListFloat128 aFixedListFloat128) return Equals(aFixedListFloat128);
            return false;    
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<float>
        {
            FixedListFloat128 m_List;
            int m_Index;

            public Enumerator(ref FixedListFloat128 list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let FixedListFloat128 indexer check for out of range.
            public float Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<float> IEnumerable<float>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class FixedListFloat128DebugView
    {
        FixedListFloat128 m_List;
        public FixedListFloat128DebugView(FixedListFloat128 list)
        {
            m_List = list;
        }
        public float[] Items => m_List.ToArray();
    }

    
}
